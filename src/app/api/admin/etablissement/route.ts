import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"
import { auth } from "@/lib/auth"
import { z } from "zod"

const etablissementSchema = z.object({
    nom: z.string().min(2, { message: "Le nom doit contenir au moins 2 caract√®res" }),
    sousDomaine: z
        .string()
        .min(2, { message: "Le sous-domaine doit contenir au moins 2 caract√®res" })
        .regex(/^[a-z0-9-]+$/, {
            message: "Le sous-domaine ne peut contenir que des lettres minuscules, des chiffres et des tirets",
        }),
})

export async function GET() {
    try {
        const etablissements = await prisma.etablissement.findMany({
            include: {
                users: true, // üî• R√©cup√®re tous les utilisateurs li√©s √† l'√©tablissement
            },
            orderBy: {
                nom: "asc",
            },
        })

        return NextResponse.json(etablissements)
    } catch (error) {
        console.error("Error fetching etablissements:", error)
        return NextResponse.json(
            { message: "Une erreur est survenue lors de la r√©cup√©ration des √©tablissements" },
            { status: 500 },
        )
    }
}

export async function POST(request: Request) {
    try {
        const session = await auth()

        // V√©rifier si l'utilisateur est un SUPER_ADMIN
        if (!session?.user?.role || session.user.role !== "SUPER_ADMIN") {
            return NextResponse.json(
                { message: "Non autoris√©. Seuls les super administrateurs peuvent cr√©er des √©tablissements." },
                { status: 403 },
            )
        }

        const body = await request.json()

        // Valider les donn√©es
        const validatedData = etablissementSchema.parse(body)

        // V√©rifier si un √©tablissement avec le m√™me nom ou sous-domaine existe d√©j√†
        const existingEtablissement = await prisma.etablissement.findFirst({
            include: {
                users: true, // üî• R√©cup√®re les utilisateurs li√©s √† l'√©tablissement
            },
            where: {
                OR: [{ nom: validatedData.nom }, { sousDomaine: validatedData.sousDomaine }],
            },
        })

        if (existingEtablissement) {
            return NextResponse.json(
                { message: "Un √©tablissement avec ce nom ou ce sous-domaine existe d√©j√†" },
                { status: 400 },
            )
        }

        // Cr√©er l'√©tablissement
        const etablissement = await prisma.etablissement.create({
            data: {
                nom: validatedData.nom,
                sousDomaine: validatedData.sousDomaine,
            },
        })

        return NextResponse.json({ message: "√âtablissement cr√©√© avec succ√®s", etablissement }, { status: 201 })
    } catch (error) {
        if (error instanceof z.ZodError) {
            return NextResponse.json({ message: "Donn√©es invalides", errors: error.errors }, { status: 400 })
        }

        console.error("Error creating etablissement:", error)
        return NextResponse.json(
            { message: "Une erreur est survenue lors de la cr√©ation de l'√©tablissement" },
            { status: 500 },
        )
    }
}

